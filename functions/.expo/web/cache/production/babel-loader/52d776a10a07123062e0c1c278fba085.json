{"ast":null,"code":"'use strict';var utils=require(\"../utils/common\");var trees=require(\"./trees\");var adler32=require(\"./adler32\");var crc32=require(\"./crc32\");var msg=require(\"./messages\");var Z_NO_FLUSH=0;var Z_PARTIAL_FLUSH=1;var Z_FULL_FLUSH=3;var Z_FINISH=4;var Z_BLOCK=5;var Z_OK=0;var Z_STREAM_END=1;var Z_STREAM_ERROR=-2;var Z_DATA_ERROR=-3;var Z_BUF_ERROR=-5;var Z_DEFAULT_COMPRESSION=-1;var Z_FILTERED=1;var Z_HUFFMAN_ONLY=2;var Z_RLE=3;var Z_FIXED=4;var Z_DEFAULT_STRATEGY=0;var Z_UNKNOWN=2;var Z_DEFLATED=8;var MAX_MEM_LEVEL=9;var MAX_WBITS=15;var DEF_MEM_LEVEL=8;var LENGTH_CODES=29;var LITERALS=256;var L_CODES=LITERALS+1+LENGTH_CODES;var D_CODES=30;var BL_CODES=19;var HEAP_SIZE=2*L_CODES+1;var MAX_BITS=15;var MIN_MATCH=3;var MAX_MATCH=258;var MIN_LOOKAHEAD=MAX_MATCH+MIN_MATCH+1;var PRESET_DICT=0x20;var INIT_STATE=42;var EXTRA_STATE=69;var NAME_STATE=73;var COMMENT_STATE=91;var HCRC_STATE=103;var BUSY_STATE=113;var FINISH_STATE=666;var BS_NEED_MORE=1;var BS_BLOCK_DONE=2;var BS_FINISH_STARTED=3;var BS_FINISH_DONE=4;var OS_CODE=0x03;function err(strm,errorCode){strm.msg=msg[errorCode];return errorCode;}function rank(f){return(f<<1)-(f>4?9:0);}function zero(buf){var len=buf.length;while(--len>=0){buf[len]=0;}}function flush_pending(strm){var s=strm.state;var len=s.pending;if(len>strm.avail_out){len=strm.avail_out;}if(len===0){return;}utils.arraySet(strm.output,s.pending_buf,s.pending_out,len,strm.next_out);strm.next_out+=len;s.pending_out+=len;strm.total_out+=len;strm.avail_out-=len;s.pending-=len;if(s.pending===0){s.pending_out=0;}}function flush_block_only(s,last){trees._tr_flush_block(s,s.block_start>=0?s.block_start:-1,s.strstart-s.block_start,last);s.block_start=s.strstart;flush_pending(s.strm);}function put_byte(s,b){s.pending_buf[s.pending++]=b;}function putShortMSB(s,b){s.pending_buf[s.pending++]=b>>>8&0xff;s.pending_buf[s.pending++]=b&0xff;}function read_buf(strm,buf,start,size){var len=strm.avail_in;if(len>size){len=size;}if(len===0){return 0;}strm.avail_in-=len;utils.arraySet(buf,strm.input,strm.next_in,len,start);if(strm.state.wrap===1){strm.adler=adler32(strm.adler,buf,len,start);}else if(strm.state.wrap===2){strm.adler=crc32(strm.adler,buf,len,start);}strm.next_in+=len;strm.total_in+=len;return len;}function longest_match(s,cur_match){var chain_length=s.max_chain_length;var scan=s.strstart;var match;var len;var best_len=s.prev_length;var nice_match=s.nice_match;var limit=s.strstart>s.w_size-MIN_LOOKAHEAD?s.strstart-(s.w_size-MIN_LOOKAHEAD):0;var _win=s.window;var wmask=s.w_mask;var prev=s.prev;var strend=s.strstart+MAX_MATCH;var scan_end1=_win[scan+best_len-1];var scan_end=_win[scan+best_len];if(s.prev_length>=s.good_match){chain_length>>=2;}if(nice_match>s.lookahead){nice_match=s.lookahead;}do{match=cur_match;if(_win[match+best_len]!==scan_end||_win[match+best_len-1]!==scan_end1||_win[match]!==_win[scan]||_win[++match]!==_win[scan+1]){continue;}scan+=2;match++;do{}while(_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&scan<strend);len=MAX_MATCH-(strend-scan);scan=strend-MAX_MATCH;if(len>best_len){s.match_start=cur_match;best_len=len;if(len>=nice_match){break;}scan_end1=_win[scan+best_len-1];scan_end=_win[scan+best_len];}}while((cur_match=prev[cur_match&wmask])>limit&&--chain_length!==0);if(best_len<=s.lookahead){return best_len;}return s.lookahead;}function fill_window(s){var _w_size=s.w_size;var p,n,m,more,str;do{more=s.window_size-s.lookahead-s.strstart;if(s.strstart>=_w_size+(_w_size-MIN_LOOKAHEAD)){utils.arraySet(s.window,s.window,_w_size,_w_size,0);s.match_start-=_w_size;s.strstart-=_w_size;s.block_start-=_w_size;n=s.hash_size;p=n;do{m=s.head[--p];s.head[p]=m>=_w_size?m-_w_size:0;}while(--n);n=_w_size;p=n;do{m=s.prev[--p];s.prev[p]=m>=_w_size?m-_w_size:0;}while(--n);more+=_w_size;}if(s.strm.avail_in===0){break;}n=read_buf(s.strm,s.window,s.strstart+s.lookahead,more);s.lookahead+=n;if(s.lookahead+s.insert>=MIN_MATCH){str=s.strstart-s.insert;s.ins_h=s.window[str];s.ins_h=(s.ins_h<<s.hash_shift^s.window[str+1])&s.hash_mask;while(s.insert){s.ins_h=(s.ins_h<<s.hash_shift^s.window[str+MIN_MATCH-1])&s.hash_mask;s.prev[str&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=str;str++;s.insert--;if(s.lookahead+s.insert<MIN_MATCH){break;}}}}while(s.lookahead<MIN_LOOKAHEAD&&s.strm.avail_in!==0);}function deflate_stored(s,flush){var max_block_size=0xffff;if(max_block_size>s.pending_buf_size-5){max_block_size=s.pending_buf_size-5;}for(;;){if(s.lookahead<=1){fill_window(s);if(s.lookahead===0&&flush===Z_NO_FLUSH){return BS_NEED_MORE;}if(s.lookahead===0){break;}}s.strstart+=s.lookahead;s.lookahead=0;var max_start=s.block_start+max_block_size;if(s.strstart===0||s.strstart>=max_start){s.lookahead=s.strstart-max_start;s.strstart=max_start;flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}if(s.strstart-s.block_start>=s.w_size-MIN_LOOKAHEAD){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}}s.insert=0;if(flush===Z_FINISH){flush_block_only(s,true);if(s.strm.avail_out===0){return BS_FINISH_STARTED;}return BS_FINISH_DONE;}if(s.strstart>s.block_start){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}return BS_NEED_MORE;}function deflate_fast(s,flush){var hash_head;var bflush;for(;;){if(s.lookahead<MIN_LOOKAHEAD){fill_window(s);if(s.lookahead<MIN_LOOKAHEAD&&flush===Z_NO_FLUSH){return BS_NEED_MORE;}if(s.lookahead===0){break;}}hash_head=0;if(s.lookahead>=MIN_MATCH){s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+MIN_MATCH-1])&s.hash_mask;hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=s.strstart;}if(hash_head!==0&&s.strstart-hash_head<=s.w_size-MIN_LOOKAHEAD){s.match_length=longest_match(s,hash_head);}if(s.match_length>=MIN_MATCH){bflush=trees._tr_tally(s,s.strstart-s.match_start,s.match_length-MIN_MATCH);s.lookahead-=s.match_length;if(s.match_length<=s.max_lazy_match&&s.lookahead>=MIN_MATCH){s.match_length--;do{s.strstart++;s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+MIN_MATCH-1])&s.hash_mask;hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=s.strstart;}while(--s.match_length!==0);s.strstart++;}else{s.strstart+=s.match_length;s.match_length=0;s.ins_h=s.window[s.strstart];s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+1])&s.hash_mask;}}else{bflush=trees._tr_tally(s,0,s.window[s.strstart]);s.lookahead--;s.strstart++;}if(bflush){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}}s.insert=s.strstart<MIN_MATCH-1?s.strstart:MIN_MATCH-1;if(flush===Z_FINISH){flush_block_only(s,true);if(s.strm.avail_out===0){return BS_FINISH_STARTED;}return BS_FINISH_DONE;}if(s.last_lit){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}return BS_BLOCK_DONE;}function deflate_slow(s,flush){var hash_head;var bflush;var max_insert;for(;;){if(s.lookahead<MIN_LOOKAHEAD){fill_window(s);if(s.lookahead<MIN_LOOKAHEAD&&flush===Z_NO_FLUSH){return BS_NEED_MORE;}if(s.lookahead===0){break;}}hash_head=0;if(s.lookahead>=MIN_MATCH){s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+MIN_MATCH-1])&s.hash_mask;hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=s.strstart;}s.prev_length=s.match_length;s.prev_match=s.match_start;s.match_length=MIN_MATCH-1;if(hash_head!==0&&s.prev_length<s.max_lazy_match&&s.strstart-hash_head<=s.w_size-MIN_LOOKAHEAD){s.match_length=longest_match(s,hash_head);if(s.match_length<=5&&(s.strategy===Z_FILTERED||s.match_length===MIN_MATCH&&s.strstart-s.match_start>4096)){s.match_length=MIN_MATCH-1;}}if(s.prev_length>=MIN_MATCH&&s.match_length<=s.prev_length){max_insert=s.strstart+s.lookahead-MIN_MATCH;bflush=trees._tr_tally(s,s.strstart-1-s.prev_match,s.prev_length-MIN_MATCH);s.lookahead-=s.prev_length-1;s.prev_length-=2;do{if(++s.strstart<=max_insert){s.ins_h=(s.ins_h<<s.hash_shift^s.window[s.strstart+MIN_MATCH-1])&s.hash_mask;hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=s.strstart;}}while(--s.prev_length!==0);s.match_available=0;s.match_length=MIN_MATCH-1;s.strstart++;if(bflush){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}}else if(s.match_available){bflush=trees._tr_tally(s,0,s.window[s.strstart-1]);if(bflush){flush_block_only(s,false);}s.strstart++;s.lookahead--;if(s.strm.avail_out===0){return BS_NEED_MORE;}}else{s.match_available=1;s.strstart++;s.lookahead--;}}if(s.match_available){bflush=trees._tr_tally(s,0,s.window[s.strstart-1]);s.match_available=0;}s.insert=s.strstart<MIN_MATCH-1?s.strstart:MIN_MATCH-1;if(flush===Z_FINISH){flush_block_only(s,true);if(s.strm.avail_out===0){return BS_FINISH_STARTED;}return BS_FINISH_DONE;}if(s.last_lit){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}return BS_BLOCK_DONE;}function deflate_rle(s,flush){var bflush;var prev;var scan,strend;var _win=s.window;for(;;){if(s.lookahead<=MAX_MATCH){fill_window(s);if(s.lookahead<=MAX_MATCH&&flush===Z_NO_FLUSH){return BS_NEED_MORE;}if(s.lookahead===0){break;}}s.match_length=0;if(s.lookahead>=MIN_MATCH&&s.strstart>0){scan=s.strstart-1;prev=_win[scan];if(prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]){strend=s.strstart+MAX_MATCH;do{}while(prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&scan<strend);s.match_length=MAX_MATCH-(strend-scan);if(s.match_length>s.lookahead){s.match_length=s.lookahead;}}}if(s.match_length>=MIN_MATCH){bflush=trees._tr_tally(s,1,s.match_length-MIN_MATCH);s.lookahead-=s.match_length;s.strstart+=s.match_length;s.match_length=0;}else{bflush=trees._tr_tally(s,0,s.window[s.strstart]);s.lookahead--;s.strstart++;}if(bflush){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}}s.insert=0;if(flush===Z_FINISH){flush_block_only(s,true);if(s.strm.avail_out===0){return BS_FINISH_STARTED;}return BS_FINISH_DONE;}if(s.last_lit){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}return BS_BLOCK_DONE;}function deflate_huff(s,flush){var bflush;for(;;){if(s.lookahead===0){fill_window(s);if(s.lookahead===0){if(flush===Z_NO_FLUSH){return BS_NEED_MORE;}break;}}s.match_length=0;bflush=trees._tr_tally(s,0,s.window[s.strstart]);s.lookahead--;s.strstart++;if(bflush){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}}s.insert=0;if(flush===Z_FINISH){flush_block_only(s,true);if(s.strm.avail_out===0){return BS_FINISH_STARTED;}return BS_FINISH_DONE;}if(s.last_lit){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE;}}return BS_BLOCK_DONE;}function Config(good_length,max_lazy,nice_length,max_chain,func){this.good_length=good_length;this.max_lazy=max_lazy;this.nice_length=nice_length;this.max_chain=max_chain;this.func=func;}var configuration_table;configuration_table=[new Config(0,0,0,0,deflate_stored),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)];function lm_init(s){s.window_size=2*s.w_size;zero(s.head);s.max_lazy_match=configuration_table[s.level].max_lazy;s.good_match=configuration_table[s.level].good_length;s.nice_match=configuration_table[s.level].nice_length;s.max_chain_length=configuration_table[s.level].max_chain;s.strstart=0;s.block_start=0;s.lookahead=0;s.insert=0;s.match_length=s.prev_length=MIN_MATCH-1;s.match_available=0;s.ins_h=0;}function DeflateState(){this.strm=null;this.status=0;this.pending_buf=null;this.pending_buf_size=0;this.pending_out=0;this.pending=0;this.wrap=0;this.gzhead=null;this.gzindex=0;this.method=Z_DEFLATED;this.last_flush=-1;this.w_size=0;this.w_bits=0;this.w_mask=0;this.window=null;this.window_size=0;this.prev=null;this.head=null;this.ins_h=0;this.hash_size=0;this.hash_bits=0;this.hash_mask=0;this.hash_shift=0;this.block_start=0;this.match_length=0;this.prev_match=0;this.match_available=0;this.strstart=0;this.match_start=0;this.lookahead=0;this.prev_length=0;this.max_chain_length=0;this.max_lazy_match=0;this.level=0;this.strategy=0;this.good_match=0;this.nice_match=0;this.dyn_ltree=new utils.Buf16(HEAP_SIZE*2);this.dyn_dtree=new utils.Buf16((2*D_CODES+1)*2);this.bl_tree=new utils.Buf16((2*BL_CODES+1)*2);zero(this.dyn_ltree);zero(this.dyn_dtree);zero(this.bl_tree);this.l_desc=null;this.d_desc=null;this.bl_desc=null;this.bl_count=new utils.Buf16(MAX_BITS+1);this.heap=new utils.Buf16(2*L_CODES+1);zero(this.heap);this.heap_len=0;this.heap_max=0;this.depth=new utils.Buf16(2*L_CODES+1);zero(this.depth);this.l_buf=0;this.lit_bufsize=0;this.last_lit=0;this.d_buf=0;this.opt_len=0;this.static_len=0;this.matches=0;this.insert=0;this.bi_buf=0;this.bi_valid=0;}function deflateResetKeep(strm){var s;if(!strm||!strm.state){return err(strm,Z_STREAM_ERROR);}strm.total_in=strm.total_out=0;strm.data_type=Z_UNKNOWN;s=strm.state;s.pending=0;s.pending_out=0;if(s.wrap<0){s.wrap=-s.wrap;}s.status=s.wrap?INIT_STATE:BUSY_STATE;strm.adler=s.wrap===2?0:1;s.last_flush=Z_NO_FLUSH;trees._tr_init(s);return Z_OK;}function deflateReset(strm){var ret=deflateResetKeep(strm);if(ret===Z_OK){lm_init(strm.state);}return ret;}function deflateSetHeader(strm,head){if(!strm||!strm.state){return Z_STREAM_ERROR;}if(strm.state.wrap!==2){return Z_STREAM_ERROR;}strm.state.gzhead=head;return Z_OK;}function deflateInit2(strm,level,method,windowBits,memLevel,strategy){if(!strm){return Z_STREAM_ERROR;}var wrap=1;if(level===Z_DEFAULT_COMPRESSION){level=6;}if(windowBits<0){wrap=0;windowBits=-windowBits;}else if(windowBits>15){wrap=2;windowBits-=16;}if(memLevel<1||memLevel>MAX_MEM_LEVEL||method!==Z_DEFLATED||windowBits<8||windowBits>15||level<0||level>9||strategy<0||strategy>Z_FIXED){return err(strm,Z_STREAM_ERROR);}if(windowBits===8){windowBits=9;}var s=new DeflateState();strm.state=s;s.strm=strm;s.wrap=wrap;s.gzhead=null;s.w_bits=windowBits;s.w_size=1<<s.w_bits;s.w_mask=s.w_size-1;s.hash_bits=memLevel+7;s.hash_size=1<<s.hash_bits;s.hash_mask=s.hash_size-1;s.hash_shift=~~((s.hash_bits+MIN_MATCH-1)/MIN_MATCH);s.window=new utils.Buf8(s.w_size*2);s.head=new utils.Buf16(s.hash_size);s.prev=new utils.Buf16(s.w_size);s.lit_bufsize=1<<memLevel+6;s.pending_buf_size=s.lit_bufsize*4;s.pending_buf=new utils.Buf8(s.pending_buf_size);s.d_buf=1*s.lit_bufsize;s.l_buf=(1+2)*s.lit_bufsize;s.level=level;s.strategy=strategy;s.method=method;return deflateReset(strm);}function deflateInit(strm,level){return deflateInit2(strm,level,Z_DEFLATED,MAX_WBITS,DEF_MEM_LEVEL,Z_DEFAULT_STRATEGY);}function deflate(strm,flush){var old_flush,s;var beg,val;if(!strm||!strm.state||flush>Z_BLOCK||flush<0){return strm?err(strm,Z_STREAM_ERROR):Z_STREAM_ERROR;}s=strm.state;if(!strm.output||!strm.input&&strm.avail_in!==0||s.status===FINISH_STATE&&flush!==Z_FINISH){return err(strm,strm.avail_out===0?Z_BUF_ERROR:Z_STREAM_ERROR);}s.strm=strm;old_flush=s.last_flush;s.last_flush=flush;if(s.status===INIT_STATE){if(s.wrap===2){strm.adler=0;put_byte(s,31);put_byte(s,139);put_byte(s,8);if(!s.gzhead){put_byte(s,0);put_byte(s,0);put_byte(s,0);put_byte(s,0);put_byte(s,0);put_byte(s,s.level===9?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0);put_byte(s,OS_CODE);s.status=BUSY_STATE;}else{put_byte(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(!s.gzhead.extra?0:4)+(!s.gzhead.name?0:8)+(!s.gzhead.comment?0:16));put_byte(s,s.gzhead.time&0xff);put_byte(s,s.gzhead.time>>8&0xff);put_byte(s,s.gzhead.time>>16&0xff);put_byte(s,s.gzhead.time>>24&0xff);put_byte(s,s.level===9?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0);put_byte(s,s.gzhead.os&0xff);if(s.gzhead.extra&&s.gzhead.extra.length){put_byte(s,s.gzhead.extra.length&0xff);put_byte(s,s.gzhead.extra.length>>8&0xff);}if(s.gzhead.hcrc){strm.adler=crc32(strm.adler,s.pending_buf,s.pending,0);}s.gzindex=0;s.status=EXTRA_STATE;}}else{var header=Z_DEFLATED+(s.w_bits-8<<4)<<8;var level_flags=-1;if(s.strategy>=Z_HUFFMAN_ONLY||s.level<2){level_flags=0;}else if(s.level<6){level_flags=1;}else if(s.level===6){level_flags=2;}else{level_flags=3;}header|=level_flags<<6;if(s.strstart!==0){header|=PRESET_DICT;}header+=31-header%31;s.status=BUSY_STATE;putShortMSB(s,header);if(s.strstart!==0){putShortMSB(s,strm.adler>>>16);putShortMSB(s,strm.adler&0xffff);}strm.adler=1;}}if(s.status===EXTRA_STATE){if(s.gzhead.extra){beg=s.pending;while(s.gzindex<(s.gzhead.extra.length&0xffff)){if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg);}flush_pending(strm);beg=s.pending;if(s.pending===s.pending_buf_size){break;}}put_byte(s,s.gzhead.extra[s.gzindex]&0xff);s.gzindex++;}if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg);}if(s.gzindex===s.gzhead.extra.length){s.gzindex=0;s.status=NAME_STATE;}}else{s.status=NAME_STATE;}}if(s.status===NAME_STATE){if(s.gzhead.name){beg=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg);}flush_pending(strm);beg=s.pending;if(s.pending===s.pending_buf_size){val=1;break;}}if(s.gzindex<s.gzhead.name.length){val=s.gzhead.name.charCodeAt(s.gzindex++)&0xff;}else{val=0;}put_byte(s,val);}while(val!==0);if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg);}if(val===0){s.gzindex=0;s.status=COMMENT_STATE;}}else{s.status=COMMENT_STATE;}}if(s.status===COMMENT_STATE){if(s.gzhead.comment){beg=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg);}flush_pending(strm);beg=s.pending;if(s.pending===s.pending_buf_size){val=1;break;}}if(s.gzindex<s.gzhead.comment.length){val=s.gzhead.comment.charCodeAt(s.gzindex++)&0xff;}else{val=0;}put_byte(s,val);}while(val!==0);if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32(strm.adler,s.pending_buf,s.pending-beg,beg);}if(val===0){s.status=HCRC_STATE;}}else{s.status=HCRC_STATE;}}if(s.status===HCRC_STATE){if(s.gzhead.hcrc){if(s.pending+2>s.pending_buf_size){flush_pending(strm);}if(s.pending+2<=s.pending_buf_size){put_byte(s,strm.adler&0xff);put_byte(s,strm.adler>>8&0xff);strm.adler=0;s.status=BUSY_STATE;}}else{s.status=BUSY_STATE;}}if(s.pending!==0){flush_pending(strm);if(strm.avail_out===0){s.last_flush=-1;return Z_OK;}}else if(strm.avail_in===0&&rank(flush)<=rank(old_flush)&&flush!==Z_FINISH){return err(strm,Z_BUF_ERROR);}if(s.status===FINISH_STATE&&strm.avail_in!==0){return err(strm,Z_BUF_ERROR);}if(strm.avail_in!==0||s.lookahead!==0||flush!==Z_NO_FLUSH&&s.status!==FINISH_STATE){var bstate=s.strategy===Z_HUFFMAN_ONLY?deflate_huff(s,flush):s.strategy===Z_RLE?deflate_rle(s,flush):configuration_table[s.level].func(s,flush);if(bstate===BS_FINISH_STARTED||bstate===BS_FINISH_DONE){s.status=FINISH_STATE;}if(bstate===BS_NEED_MORE||bstate===BS_FINISH_STARTED){if(strm.avail_out===0){s.last_flush=-1;}return Z_OK;}if(bstate===BS_BLOCK_DONE){if(flush===Z_PARTIAL_FLUSH){trees._tr_align(s);}else if(flush!==Z_BLOCK){trees._tr_stored_block(s,0,0,false);if(flush===Z_FULL_FLUSH){zero(s.head);if(s.lookahead===0){s.strstart=0;s.block_start=0;s.insert=0;}}}flush_pending(strm);if(strm.avail_out===0){s.last_flush=-1;return Z_OK;}}}if(flush!==Z_FINISH){return Z_OK;}if(s.wrap<=0){return Z_STREAM_END;}if(s.wrap===2){put_byte(s,strm.adler&0xff);put_byte(s,strm.adler>>8&0xff);put_byte(s,strm.adler>>16&0xff);put_byte(s,strm.adler>>24&0xff);put_byte(s,strm.total_in&0xff);put_byte(s,strm.total_in>>8&0xff);put_byte(s,strm.total_in>>16&0xff);put_byte(s,strm.total_in>>24&0xff);}else{putShortMSB(s,strm.adler>>>16);putShortMSB(s,strm.adler&0xffff);}flush_pending(strm);if(s.wrap>0){s.wrap=-s.wrap;}return s.pending!==0?Z_OK:Z_STREAM_END;}function deflateEnd(strm){var status;if(!strm||!strm.state){return Z_STREAM_ERROR;}status=strm.state.status;if(status!==INIT_STATE&&status!==EXTRA_STATE&&status!==NAME_STATE&&status!==COMMENT_STATE&&status!==HCRC_STATE&&status!==BUSY_STATE&&status!==FINISH_STATE){return err(strm,Z_STREAM_ERROR);}strm.state=null;return status===BUSY_STATE?err(strm,Z_DATA_ERROR):Z_OK;}function deflateSetDictionary(strm,dictionary){var dictLength=dictionary.length;var s;var str,n;var wrap;var avail;var next;var input;var tmpDict;if(!strm||!strm.state){return Z_STREAM_ERROR;}s=strm.state;wrap=s.wrap;if(wrap===2||wrap===1&&s.status!==INIT_STATE||s.lookahead){return Z_STREAM_ERROR;}if(wrap===1){strm.adler=adler32(strm.adler,dictionary,dictLength,0);}s.wrap=0;if(dictLength>=s.w_size){if(wrap===0){zero(s.head);s.strstart=0;s.block_start=0;s.insert=0;}tmpDict=new utils.Buf8(s.w_size);utils.arraySet(tmpDict,dictionary,dictLength-s.w_size,s.w_size,0);dictionary=tmpDict;dictLength=s.w_size;}avail=strm.avail_in;next=strm.next_in;input=strm.input;strm.avail_in=dictLength;strm.next_in=0;strm.input=dictionary;fill_window(s);while(s.lookahead>=MIN_MATCH){str=s.strstart;n=s.lookahead-(MIN_MATCH-1);do{s.ins_h=(s.ins_h<<s.hash_shift^s.window[str+MIN_MATCH-1])&s.hash_mask;s.prev[str&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=str;str++;}while(--n);s.strstart=str;s.lookahead=MIN_MATCH-1;fill_window(s);}s.strstart+=s.lookahead;s.block_start=s.strstart;s.insert=s.lookahead;s.lookahead=0;s.match_length=s.prev_length=MIN_MATCH-1;s.match_available=0;strm.next_in=next;strm.input=input;strm.avail_in=avail;s.wrap=wrap;return Z_OK;}exports.deflateInit=deflateInit;exports.deflateInit2=deflateInit2;exports.deflateReset=deflateReset;exports.deflateResetKeep=deflateResetKeep;exports.deflateSetHeader=deflateSetHeader;exports.deflate=deflate;exports.deflateEnd=deflateEnd;exports.deflateSetDictionary=deflateSetDictionary;exports.deflateInfo='pako deflate (from Nodeca project)';","map":{"version":3,"sources":["/usr/local/lib/node_modules/expo-cli/node_modules/pako/lib/zlib/deflate.js"],"names":["utils","require","trees","adler32","crc32","msg","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_OK","Z_STREAM_END","Z_STREAM_ERROR","Z_DATA_ERROR","Z_BUF_ERROR","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_UNKNOWN","Z_DEFLATED","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","MIN_MATCH","MAX_MATCH","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","err","strm","errorCode","rank","f","zero","buf","len","length","flush_pending","s","state","pending","avail_out","arraySet","output","pending_buf","pending_out","next_out","total_out","flush_block_only","last","_tr_flush_block","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","adler","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","match","best_len","prev_length","nice_match","limit","w_size","_win","window","wmask","w_mask","prev","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","_w_size","p","n","m","more","str","window_size","hash_size","head","insert","ins_h","hash_shift","hash_mask","deflate_stored","flush","max_block_size","pending_buf_size","max_start","deflate_fast","hash_head","bflush","match_length","_tr_tally","max_lazy_match","last_lit","deflate_slow","max_insert","prev_match","strategy","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","lm_init","level","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","dyn_ltree","Buf16","dyn_dtree","bl_tree","l_desc","d_desc","bl_desc","bl_count","heap","heap_len","heap_max","depth","l_buf","lit_bufsize","d_buf","opt_len","static_len","matches","bi_buf","bi_valid","deflateResetKeep","data_type","_tr_init","deflateReset","ret","deflateSetHeader","deflateInit2","windowBits","memLevel","Buf8","deflateInit","deflate","old_flush","beg","val","text","hcrc","extra","name","comment","time","os","header","level_flags","charCodeAt","bstate","_tr_align","_tr_stored_block","deflateEnd","deflateSetDictionary","dictionary","dictLength","avail","next","tmpDict","exports","deflateInfo"],"mappings":"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","sourcesContent":["'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n"]},"metadata":{},"sourceType":"script"}