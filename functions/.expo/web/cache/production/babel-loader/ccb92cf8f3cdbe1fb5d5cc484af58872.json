{"ast":null,"code":"var _taggedTemplateLiteralLoose=require(\"@babel/runtime/helpers/taggedTemplateLiteralLoose\");var _regeneratorRuntime=require(\"@babel/runtime/regenerator\");var _toConsumableArray=require(\"@babel/runtime/helpers/toConsumableArray\");function _templateObject(){var data=_taggedTemplateLiteralLoose([\"There was an error sending a notification: \",\"\"]);_templateObject=function _templateObject(){return data;};return data;}function _createForOfIteratorHelperLoose(o){var i=0;if(typeof Symbol===\"undefined\"||o[typeof Symbol===\"function\"?Symbol.iterator:\"@@iterator\"]==null){if(Array.isArray(o)||(o=_unsupportedIterableToArray(o)))return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}i=o[typeof Symbol===\"function\"?Symbol.iterator:\"@@iterator\"]();return i.next.bind(i);}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}var functions=require('firebase-functions');var admin=require('firebase-admin');var _require=require('expo-server-sdk'),Expo=_require.Expo;admin.initializeApp(functions.config().firebase);exports.queueExpiredItemsNotifications=functions.https.onRequest(function(request,response){var expo=new Expo();var tokens=[];var messages=[];admin.firestore().collection('tokens').get().then(function(result){response.send(result);result.forEach(function(tokenDoc){tokens.push(tokenDoc.expoPushToen);});tokens.forEach(function(pushToken){if(!Expo.isExpoPushToken(pushToken)){console.error(\"Push token \"+pushToken+\" is not a valid Expo push token\");}messages.push({to:pushToken,sound:'default',body:'This is a test notification',data:{withSome:'data'}});});});var chunks=expo.chunkPushNotifications(messages);var tickets=[];(function _callee(){var _iterator,_step,chunk,ticketChunk;return _regeneratorRuntime.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_iterator=_createForOfIteratorHelperLoose(chunks);case 1:if((_step=_iterator()).done){_context.next=16;break;}chunk=_step.value;_context.prev=3;_context.next=6;return _regeneratorRuntime.awrap(expo.sendPushNotificationsAsync(chunk));case 6:ticketChunk=_context.sent;console.log(ticketChunk);tickets.push.apply(tickets,_toConsumableArray(ticketChunk));_context.next=14;break;case 11:_context.prev=11;_context.t0=_context[\"catch\"](3);console.error(_context.t0);case 14:_context.next=1;break;case 16:case\"end\":return _context.stop();}}},null,null,[[3,11]],Promise);})();var receiptIds=[];for(var _i=0,_tickets=tickets;_i<_tickets.length;_i++){var ticket=_tickets[_i];if(ticket.id){receiptIds.push(ticket.id);}}var receiptIdChunks=expo.chunkPushNotificationReceiptIds(receiptIds);(function _callee2(){var _iterator2,_step2,chunk,receipts,receiptId,_receipts$receiptId,status,message,details;return _regeneratorRuntime.async(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_iterator2=_createForOfIteratorHelperLoose(receiptIdChunks);case 1:if((_step2=_iterator2()).done){_context2.next=26;break;}chunk=_step2.value;_context2.prev=3;_context2.next=6;return _regeneratorRuntime.awrap(expo.getPushNotificationReceiptsAsync(chunk));case 6:receipts=_context2.sent;console.log(receipts);_context2.t0=_regeneratorRuntime.keys(receipts);case 9:if((_context2.t1=_context2.t0()).done){_context2.next=19;break;}receiptId=_context2.t1.value;_receipts$receiptId=receipts[receiptId],status=_receipts$receiptId.status,message=_receipts$receiptId.message,details=_receipts$receiptId.details;if(!(status==='ok')){_context2.next=16;break;}return _context2.abrupt(\"continue\",9);case 16:if(status==='error'){console.error(n(_templateObject(),message));if(details&&details.error){console.error(\"The error code is \"+details.error);}}case 17:_context2.next=9;break;case 19:_context2.next=24;break;case 21:_context2.prev=21;_context2.t2=_context2[\"catch\"](3);console.error(_context2.t2);case 24:_context2.next=1;break;case 26:case\"end\":return _context2.stop();}}},null,null,[[3,21]],Promise);})();});","map":{"version":3,"sources":["/Users/sebastian/Projects/DM2518/dm2518-mdwwt-project/functions/index.js"],"names":["functions","require","admin","Expo","initializeApp","config","firebase","exports","queueExpiredItemsNotifications","https","onRequest","request","response","expo","tokens","messages","firestore","collection","get","then","result","send","forEach","tokenDoc","push","expoPushToen","pushToken","isExpoPushToken","console","error","to","sound","body","data","withSome","chunks","chunkPushNotifications","tickets","chunk","sendPushNotificationsAsync","ticketChunk","log","receiptIds","ticket","id","receiptIdChunks","chunkPushNotificationReceiptIds","getPushNotificationReceiptsAsync","receipts","receiptId","status","message","details","n"],"mappings":"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","sourcesContent":["const functions = require('firebase-functions');\nconst admin = require('firebase-admin');\nconst { Expo } = require('expo-server-sdk')\nadmin.initializeApp(functions.config().firebase);\n\nexports.queueExpiredItemsNotifications = functions.https.onRequest((request, response) => {\n  \n  // Create a new Expo SDK client\n\tlet expo = new Expo();\n\tconst tokens = [];\n\tlet messages = [];\n\t// Create the messages that you want to send to clents\n\tadmin.firestore().collection('tokens').get().then((result) => {\n\t\tresponse.send(result);\n\t\tresult.forEach((tokenDoc) => {\n\t\t\ttokens.push(tokenDoc.expoPushToen);\n\t\t})\n\n\t\ttokens.forEach(pushToken => {\n\t\t\tif (!Expo.isExpoPushToken(pushToken)) {\n\t\t\t\tconsole.error(`Push token ${pushToken} is not a valid Expo push token`);\n\t\t\t}\n\t\n\t\t\t// Construct a message (see https://docs.expo.io/versions/latest/guides/push-notifications)\n\t\t\tmessages.push({\n\t\t\t\tto: pushToken,\n\t\t\t\tsound: 'default',\n\t\t\t\tbody: 'This is a test notification',\n\t\t\t\tdata: { withSome: 'data' },\n\t\t\t})\n\t\t})\n\t});\n\n\n\t\n\t// The Expo push notification service accepts batches of notifications so\n\t// that you don't need to send 1000 requests to send 1000 notifications. We\n\t// recommend you batch your notifications to reduce the number of requests\n\t// and to compress them (notifications with similar content will get\n\t// compressed).\n\tlet chunks = expo.chunkPushNotifications(messages);\n\tlet tickets = [];\n\t(async () => {\n\t// Send the chunks to the Expo push notification service. There are\n\t// different strategies you could use. A simple one is to send one chunk at a\n\t// time, which nicely spreads the load out over time:\n\tfor (let chunk of chunks) {\n\t\ttry {\n\t\tlet ticketChunk = await expo.sendPushNotificationsAsync(chunk);\n\t\tconsole.log(ticketChunk);\n\t\ttickets.push(...ticketChunk);\n\t\t// NOTE: If a ticket contains an error code in ticket.details.error, you\n\t\t// must handle it appropriately. The error codes are listed in the Expo\n\t\t// documentation:\n\t\t// https://docs.expo.io/versions/latest/guides/push-notifications#response-format\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\t}\n\t})();\n\n\t// Later, after the Expo push notification service has delivered the\n\t// notifications to Apple or Google (usually quickly, but allow the the service\n\t// up to 30 minutes when under load), a \"receipt\" for each notification is\n\t// created. The receipts will be available for at least a day; stale receipts\n\t// are deleted.\n\t//\n\t// The ID of each receipt is sent back in the response \"ticket\" for each\n\t// notification. In summary, sending a notification produces a ticket, which\n\t// contains a receipt ID you later use to get the receipt.\n\t//\n\t// The receipts may contain error codes to which you must respond. In\n\t// particular, Apple or Google may block apps that continue to send\n\t// notifications to devices that have blocked notifications or have uninstalled\n\t// your app. Expo does not control this policy and sends back the feedback from\n\t// Apple and Google so you can handle it appropriately.\n\tlet receiptIds = [];\n\tfor (let ticket of tickets) {\n\t// NOTE: Not all tickets have IDs; for example, tickets for notifications\n\t// that could not be enqueued will have error information and no receipt ID.\n\tif (ticket.id) {\n\t\treceiptIds.push(ticket.id);\n\t}\n\t}\n\n\tlet receiptIdChunks = expo.chunkPushNotificationReceiptIds(receiptIds);\n\t(async () => {\n\t// Like sending notifications, there are different strategies you could use\n\t// to retrieve batches of receipts from the Expo service.\n\tfor (let chunk of receiptIdChunks) {\n\t\ttry {\n\t\tlet receipts = await expo.getPushNotificationReceiptsAsync(chunk);\n\t\tconsole.log(receipts);\n\n\t\t// The receipts specify whether Apple or Google successfully received the\n\t\t// notification and information about an error, if one occurred.\n\t\tfor (let receiptId in receipts) {\n\t\t\tlet { status, message, details } = receipts[receiptId];\n\t\t\tif (status === 'ok') {\n\t\t\tcontinue;\n\t\t\t} else if (status === 'error') {\n\t\t\tconsole.error(n\n\t\t\t\t`There was an error sending a notification: ${message}`\n\t\t\t);\n\t\t\tif (details && details.error) {\n\t\t\t\t// The error codes are listed in the Expo documentation:\n\t\t\t\t// https://docs.expo.io/versions/latest/guides/push-notifications/#individual-errors\n\t\t\t\t// You must handle the errors appropriately.\n\t\t\t\tconsole.error(`The error code is ${details.error}`);\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t} catch (error) {\n\t\tconsole.error(error);\n\t\t}\n\t}\n\t})();\n\n});\n\n"]},"metadata":{},"sourceType":"script"}