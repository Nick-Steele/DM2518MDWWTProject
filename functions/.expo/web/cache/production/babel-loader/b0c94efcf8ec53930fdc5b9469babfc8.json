{"ast":null,"code":"'use strict';var BAD=30;var TYPE=12;module.exports=function inflate_fast(strm,start){var state;var _in;var last;var _out;var beg;var end;var dmax;var wsize;var whave;var wnext;var s_window;var hold;var bits;var lcode;var dcode;var lmask;var dmask;var here;var op;var len;var dist;var from;var from_source;var input,output;state=strm.state;_in=strm.next_in;input=strm.input;last=_in+(strm.avail_in-5);_out=strm.next_out;output=strm.output;beg=_out-(start-strm.avail_out);end=_out+(strm.avail_out-257);dmax=state.dmax;wsize=state.wsize;whave=state.whave;wnext=state.wnext;s_window=state.window;hold=state.hold;bits=state.bits;lcode=state.lencode;dcode=state.distcode;lmask=(1<<state.lenbits)-1;dmask=(1<<state.distbits)-1;top:do{if(bits<15){hold+=input[_in++]<<bits;bits+=8;hold+=input[_in++]<<bits;bits+=8;}here=lcode[hold&lmask];dolen:for(;;){op=here>>>24;hold>>>=op;bits-=op;op=here>>>16&0xff;if(op===0){output[_out++]=here&0xffff;}else if(op&16){len=here&0xffff;op&=15;if(op){if(bits<op){hold+=input[_in++]<<bits;bits+=8;}len+=hold&(1<<op)-1;hold>>>=op;bits-=op;}if(bits<15){hold+=input[_in++]<<bits;bits+=8;hold+=input[_in++]<<bits;bits+=8;}here=dcode[hold&dmask];dodist:for(;;){op=here>>>24;hold>>>=op;bits-=op;op=here>>>16&0xff;if(op&16){dist=here&0xffff;op&=15;if(bits<op){hold+=input[_in++]<<bits;bits+=8;if(bits<op){hold+=input[_in++]<<bits;bits+=8;}}dist+=hold&(1<<op)-1;if(dist>dmax){strm.msg='invalid distance too far back';state.mode=BAD;break top;}hold>>>=op;bits-=op;op=_out-beg;if(dist>op){op=dist-op;if(op>whave){if(state.sane){strm.msg='invalid distance too far back';state.mode=BAD;break top;}}from=0;from_source=s_window;if(wnext===0){from+=wsize-op;if(op<len){len-=op;do{output[_out++]=s_window[from++];}while(--op);from=_out-dist;from_source=output;}}else if(wnext<op){from+=wsize+wnext-op;op-=wnext;if(op<len){len-=op;do{output[_out++]=s_window[from++];}while(--op);from=0;if(wnext<len){op=wnext;len-=op;do{output[_out++]=s_window[from++];}while(--op);from=_out-dist;from_source=output;}}}else{from+=wnext-op;if(op<len){len-=op;do{output[_out++]=s_window[from++];}while(--op);from=_out-dist;from_source=output;}}while(len>2){output[_out++]=from_source[from++];output[_out++]=from_source[from++];output[_out++]=from_source[from++];len-=3;}if(len){output[_out++]=from_source[from++];if(len>1){output[_out++]=from_source[from++];}}}else{from=_out-dist;do{output[_out++]=output[from++];output[_out++]=output[from++];output[_out++]=output[from++];len-=3;}while(len>2);if(len){output[_out++]=output[from++];if(len>1){output[_out++]=output[from++];}}}}else if((op&64)===0){here=dcode[(here&0xffff)+(hold&(1<<op)-1)];continue dodist;}else{strm.msg='invalid distance code';state.mode=BAD;break top;}break;}}else if((op&64)===0){here=lcode[(here&0xffff)+(hold&(1<<op)-1)];continue dolen;}else if(op&32){state.mode=TYPE;break top;}else{strm.msg='invalid literal/length code';state.mode=BAD;break top;}break;}}while(_in<last&&_out<end);len=bits>>3;_in-=len;bits-=len<<3;hold&=(1<<bits)-1;strm.next_in=_in;strm.next_out=_out;strm.avail_in=_in<last?5+(last-_in):5-(_in-last);strm.avail_out=_out<end?257+(end-_out):257-(_out-end);state.hold=hold;state.bits=bits;return;};","map":{"version":3,"sources":["/usr/local/lib/node_modules/expo-cli/node_modules/pako/lib/zlib/inffast.js"],"names":["BAD","TYPE","module","exports","inflate_fast","strm","start","state","_in","last","_out","beg","end","dmax","wsize","whave","wnext","s_window","hold","bits","lcode","dcode","lmask","dmask","here","op","len","dist","from","from_source","input","output","next_in","avail_in","next_out","avail_out","window","lencode","distcode","lenbits","distbits","top","dolen","dodist","msg","mode","sane"],"mappings":"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","sourcesContent":["'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n"]},"metadata":{},"sourceType":"script"}